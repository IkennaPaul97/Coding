Chapter 1
-----------------------------------
An editor is used to create the text files that contain the C++ code. There are two different types of
files:
• Source files
Source files contain definitions of global variables and functions. Each C++ program consists of at
least one source file.
• Header files
Header files, also called include files, provide the information needed in various source files.
This includes:
• Type definitions, e.g. class definitions
• Declarations of global variables and functions
• Definitions of macros and inline functions\

1.1.3 Compilers
A translation unit consists of a source file and the included header files. The compiler generates an
object file (also called module) from each translation unit; the object file contains the machine
code. In addition to the compilers that generate the machine code directly, there are also C++ into
C translation programs, so-called »C-Front-Compilers«. They translate a C++ program into a C
program. Only then is the object file created with a standard C compiler.

The linker combines object files into an executable file. Besides the self-generated object files, it
also contains the startup-code and the modules with the used functions and classes of the standard library.


The output of the umlaut 'ö' using the hexadecimal notation would look like this:
cout << "Heute ist ein sch\x94ner Tag!" << endl; // \x initiates a hexadecimal escape sequence
(“Heute ist ein schöner Tag!” translated into English is “Today is a beautiful day.”)

However, this version has a catch: If the next character can also be displayed in hexadecimal or
octal form, this character will also be interpreted. For example, in the word 'Oberfl\x84che' (Oberfläche=surface), '\x84' would not be replaced with the character 'ä', but 'x84c' with the number
'2124'. However, there is a little trick for this problem:
cout << "Oberfl\x84 \bche!" << endl;


8.4 Overloading functions/member functions
Overloading means defining several member functions (= functions) with the same name, but differing in terms of the number and type of parameters.

8.5 Static
8.5.1 Static variables
Static variables retain their value and are not deleted when leaving their frame of reference


Declaration of static member variables
In C++, a class variable is declared within the class using the keyword “static”. This is why they are
also referred to as static data elements.
Example:
static int number;
The number variable is declared as a static element of the Customer class. It stores the number of
customers, i.e. the number of existing objects of the Customer type.
Definition of static member variables
Static data elements of a class occupy memory space, even if no object of the class exists. Like
member functions they must therefore be defined and initialized outside the class in a source file.
The class reference is created using the scope resolution operator (::).
Example:
int Customer : : number = 0; // There is no object yet

Not inherited are
- Friendship with another friend class
- A class-specific assignment operator operator=()
- Constructors and destructors


Access rights after derivation::
Basically, DerivedClass inherits all components of BaseClass, i.e. each instance
of DerivedClass contains an (anonymous)
object of the BaseClass type.

This sub-object is created before the additional components of DerivedClass by
implicitly calling the base class constructor.
The access right in the base class and
the access specifier during derivation
determine the access right to components
of BaseClass in DerivedClass.

private components of BaseClass are
generally not accessible in DerivedClass.
Access to private members is still only
possible using public member functions of
BaseClass. By deriving from a class, you
cannot gain access to private elements.

Important: Static variables must be initialized during their definition.